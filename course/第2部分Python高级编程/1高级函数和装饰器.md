
# 高级函数和装饰器
在 Python 中，函数是一种基本类型的对象，这意味着可以将函数作为参数传给另一个函数。

将函数作为字典的值储存，将函数作为另一个函数的返回值：


```python 
def square(x):
    """Square of x."""
    return x * x


def cube(x):
    """Cube of x."""
    return x * x * x


# 函数的作为字典的值
funcs = {'square': square, 'cube': cube, }
x = 2
for func in sorted(funcs):
    print(func, funcs[func](x))
```


```python 
func
```


```python 
funcs
```


## 函数参数
引用传递

传递给函数 f 的是一个指向 x 所包含内容的引用，
如果我们修改了这个引用所指向内容的值（例如 x[0]=999），
那么外面的 x 的值也会被改变：


```python 
def mod_f(x):
    x[0] = 999
    return x

x = [1, 2, 3]

x # [1, 2, 3]
```


```python 
mod_f(x) # [999, 2, 3]
```


```python 
x # [999, 2, 3]
```


过如果我们在函数中赋给 x 一个新的值（例如另一个列表），

那么在函数外面的 x 的值不会改变：


```python 
def no_mod_f(x):
    x = [4, 5, 6]
    return x


x = [1, 2, 3]

print(x)
print(mod_f(x))
print(x)
# [1, 2, 3]
# [999, 2, 3]
# [999, 2, 3]
```



## 高阶函数
以函数作为参数，或者返回一个函数的函数是高阶函数，
常用的例子有 map 和 filter 函数

map(f, sq) 函数将 f 作用到 sq 的每个元素上去，并返回结果组成的列表，

相当于：[f(s) for s in sq]


```python 
map(square, range(5))  # [0, 1, 4, 9, 16]
```


```python 
# 外面套个list，强转为list类型，是为了打印出函数的值
list(map(square, range(5)))
```


```python 
def is_even(x):
    return x % 2 == 0


list(filter(is_even, range(5)))  # [0, 2, 4]
```


```python 
list(map(square, filter(is_even, range(5))))  # [0, 4, 16]
```


reduce(f, sq) 函数接受一个二元操作函数 f(x,y)，
并对于序列 sq 每次合并两个元素：


```python 
from functools import reduce
def my_add(x, y):
    return x + y


reduce(my_add, [1, 2, 3])
```


返回一个函数：


```python 
def get_logger_func(target):
    def write_logger(data):
        with open(target, 'a') as f:
            f.write(data + '\n')

    return write_logger


fun_logger = get_logger_func('foo.txt')
fun_logger('hello')
```


```python 
# 查看foo.txt 是否生成
import os
os.path.exists('foo.txt')
```


## 匿名函数lambda


```python 
list(map(square, range(5)))
```


```python 
# 用匿名函数替换为：
list(map(lambda x: x * x, range(5)))
```



匿名函数虽然写起来比较方便（省去了定义函数的烦恼），
但是有时候会比较难于阅读：


```python 
s1 = reduce(lambda x, y: x + y, map(lambda x: x ** 2, range(1, 3)))
print(s1)  # 5
```


```python 
# 简单的写法：
s2 = sum(x ** 2 for x in range(1, 3))
print(s2)  # 5
```


## global 变量

要在函数中修改全局变量的值，需要加上 global 关键字：


```python 
x = 15

def print_newx():
    global x
    x = 18
    print(x)


print_newx()
print(x)

# 18
# 18
```


如果不加上这句 global 那么全局变量的值不会改变：


```python 
x = 15


def print_newx2():
    x = 18
    print(x)


print_newx2()
print(x)


# 18
# 15
```



## 递归
一般对于分治法，要用递归，不过在python中不怎么用，更高效的处理非波切利算法：


```python 
def fib(n):
    """Fib without recursion."""
    a, b = 0, 1
    for i in range(1, n + 1):
        a, b = b, a + b
    return b


print([fib(i) for i in range(10)])

```



# 装饰器：Decorator
如果你有一批变量想统一按一个规则处理，并且需要缩减代码，你需要函数。

如果你有一批函数想统一按一个规则处理，并且需要缩减代码，你需要装饰器（Decorator）

理清下面2点：

函数
- 接受参数
- 做点事情
- 返回结果


装饰器
- 接受函数作为参数
- 做点事情
- 返回一个函数


用 @ 来使用装饰器

使用 @ 符号来将某个函数替换为装饰符之后的函数：

例如这个函数：


```python 
def dec(f):
    print('I am decorating function', id(f))
    return f
```


```python 
def foo(x):
    print(x)  # I am decorating function 45206384
```


```python 
foo = dec(foo)
```


可以替换为：



```python 
@dec
def foo(x):
    print(x)
```


### 例子
定义两个装饰器函数，一个将原来的函数值加一，另一个乘二：


```python 
def plus_one(f):
    def new_func(x):
        return f(x) + 1

    return new_func
```


```python 
def times_two(f):
    def new_func(x):
        return f(x) * 2

    return new_func
```


定义函数，先乘二再加一：


```python 
@plus_one
@times_two
def foo(x):
    return int(x)
```


```python 
b = foo(2)
b  # 5
```


## 修饰器工厂
decorators factories 是返回修饰器的函数

它的作用在于产生一个可以接受参数的修饰器，

例如我们想将 函数 输出的内容写入一个文件去，可以这样做：


```python 
def super_loud(filename):
    fp = open(filename, 'w')

    def loud(f):
        def new_func(*args, **kw):
            fp.write(str(args))
            fp.writelines('\n')
            fp.write('calling with' + str(args) + str(kw))
            # 确保内容被写入
            fp.flush()
            fp.close()
            rtn = f(*args, **kw)
            return rtn

        return new_func

    return loud
```


```python 
@super_loud('test.txt')
def foo(x):
    print(x)


# 调用 foo 就会在文件中写入内容：
foo(100)
```


```python 
import os
os.remove('test.txt')
```


## @classmethod 装饰器
在 Python 标准库中，有很多自带的装饰器，

例如 classmethod 将一个对象方法转换了类方法：


```python 
class Foo(object):
    @classmethod
    def bar(cls, x):
        print('the input is', x)

    def __init__(self):
        pass
```


类方法可以通过 类名.方法 来调用：


```python 
Foo.bar(10)
```


## @property 装饰器
有时候，我们希望像 Java 一样支持 getters 和 setters 的方法，

这时候就可以使用 property 装饰器：


```python 
class Foo(object):
    def __init__(self, data):
        self.data = data

    @property
    def x(self):
        return self.data

```


此时可以使用 .x 这个属性查看数据（不需要加上括号）：


```python 
foo = Foo(22)
print(foo.x)
```


这样做的好处在于，这个属性是只读的：

foo.x = 1 会报错


如果想让它变成可读写，可以加上一个装饰符 @x.setter：


```python 
class Foo(object):
    def __init__(self, data):
        self.data = data

    @property
    def x(self):
        return self.data

    @x.setter
    def x(self, value):
        self.data = value
```


```python 
foo = Foo(1000)
foo.x
```


```python 
foo.x = 2222
foo.x
```


## 应用：定时器

要求：写一个定时器功能，要求监控一个执行程序，超时则报警。

如何完成？

下方代码在mac下可用


```python 

import signal
import time


def set_timeout(num, callback):
    def wrap(func):
        def handle(signum, frame):  # 收到信号 SIGALRM 后的回调函数，参数1是信号的数字，参数2是the interrupted stack frame.
            raise RuntimeError

        def to_do(*args, **kwargs):
            try:
                signal.signal(signal.SIGALRM, handle)  # 设置信号和回调函数
                signal.alarm(num)  # 设置 num 秒的闹钟
                print('start alarm signal.')
                r = func(*args, **kwargs)
                print('close alarm signal.')
                signal.alarm(0)  # 关闭闹钟
                return r
            except RuntimeError as e:
                callback()

        return to_do

    return wrap


def after_timeout():  # 超时后的处理函数
    print("do something after timeout.")
    raise RuntimeError


@set_timeout(2, after_timeout)  # 限时 2 秒超时
def connect():  # 要执行的函数
    time.sleep(2.4)  # 函数执行时间，写大于2的值，可测试超时
    return "完成"

class Demo:
    @set_timeout(2, after_timeout)
    def conn(self):
        time.sleep(3)
        return "ok"
```


试一下：


```python 
try:
    a = connect()
    print(a)
except Exception as e:
    a = 'err'
    print(a)

```


如果不超时：


```python 
b = Demo()
try:
    c = b.conn()
    print(c)
except RuntimeError as e:
    print('run time err.')

class Demo:
    @set_timeout(2, after_timeout)
    def conn(self):
        time.sleep(1)
        return "ok"
    
b = Demo()
try:
    c = b.conn()
    print(c)
except RuntimeError as e:
    print('run time err.')
```

