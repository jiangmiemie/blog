---
tags: [python,imageio]
---
``` python

'''
图片拼接
'''

# encoding: utf-8
def merge_LR(pics): #左右拼接
    from imageio import imread
    import skimage.io as io
    import numpy as np
    A_wordcould_path = 'wordcould1.png'#合并后图片的名字
    #横向拼接
    图片1 = io.imread(pics[0])   # np.ndarray, [h, w, c], 值域(0, 255), RGB
    图片2 = io.imread(pics[1])   # np.ndarray, [h, w, c], 值域(0, 255), RGB
    #print(图片1.dtype)
    图片1_h = 图片1.shape[0]   #查看图片的大小
    图片1_w = 图片1.shape[1]
    图片1_c = 图片1.shape[2]
    图片2_h = 图片2.shape[0]   #查看图片的大小
    图片2_w = 图片2.shape[1]
    if 图片1_h >= 图片2_h :
        pj1 = np.zeros((图片1_h,图片1_w+图片2_w,图片1_c))   #横向拼接
    else:
        pj1 = np.zeros((图片2_h,图片1_w+图片2_w,图片1_c))  #横向拼接
    pj1[:,:图片1_w,:] = 图片1.copy()   #图片图片1在左
    pj1[:,图片2_w:,:] = 图片2.copy()   #图片图片2在右
    pj1=np.array(pj1,dtype=np.uint8)   #将pj1数组元素数据类型的改为"uint8"
    io.imsave(A_wordcould_path, pj1)   #保存拼接后的图片

def merge_UD(pics): #上下拼接
    from imageio import imread
    import skimage.io as io
    import numpy as np
    B_wordcould_path = 'wordcould2.png'
    # 上面与下面拼接
    图片1 = io.imread(pics[0])   # np.ndarray, [h, w, c], 值域(0, 255), RGB
    图片2 = io.imread(pics[1])   # np.ndarray, [h, w, c], 值域(0, 255), RGB
    图片1_h = 图片1.shape[0]   #查看图片的大小
    图片1_w = 图片1.shape[1]
    图片1_c = 图片1.shape[2]
    图片2_h = 图片2.shape[0]   #查看图片的大小
    图片2_w = 图片2.shape[1]
    if 图片1_w >= 图片2_w :
        pj = np.zeros((图片1_h+图片2_h,图片1_w,图片1_c))   #竖向拼接
    else:
        pj = np.zeros((图片2_h+图片2_h,图片2_w,图片1_c))  #竖向拼接
    #计算最终图片的像素大小
    pj[:图片1_h,:,:] = 图片1.copy()   #图片图片1在左
    pj[图片2_h:,:,:] = 图片2.copy()   #图片图片2在右
    pj=np.array(pj,dtype=np.uint8)   #将pj数组元素数据类型的改为"uint8"
    io.imsave(B_wordcould_path, pj)   #保存拼接后的图片

pics = ['3.png','4.png']
merge_LR(pics) #左右
#merge_UD(pics)#上下

```
