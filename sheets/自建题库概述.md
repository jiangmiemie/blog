---
tags: [python,题库]
---

# 自建题库

## 1.1 python xxx.py和python -m xxx.py有什么区别？

这是两种加载py文件的方式:
1叫做直接运行
2把模块当作脚本来启动(注意：但是__name__的值为'main' )

## return和yield有什么区别？

yield 是暂停的意思(它有程序中起着类似红绿灯中等红灯的作用)；yield是创建迭代器，可以用for来遍历，有点事件触发的意思

return  在方法中直接返回值；是函数返回值，当执行到return，后续的逻辑代码不在执行

相同点： 都是定义函数过程中返回值

不同点：yield是暂停函数，return是结束函数； 即yield返回值后继续执行函数体内代码，return返回值后不再执行函数体内代码。

yield返回的是一个迭代器（yield本身是生成器-生成器是用来生成迭代器的）；return返回的是正常可迭代对象（list,set,dict等具有实际内存地址的存储对象）

如果要返回的数据是通过for等循环生成的迭代器类型数据（如列表、元组），return只能在循环外部一次性地返回，yeild则可以在循环内部逐个元素返回。

- 哪个快：a = [] vs a = list()

[]是解析后的list，所以[]更快

- 讲一下以下几个关键字/函数的作用：map、zip、reduce

```Python
def square(x): 
    return x*x 
for i in map(square,[1,2,3]) : # map 是求一个序列或者多个序列进行函数映射之后的值
    print(i)


#zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。
a = [1,2,3] #此处可迭代对象为列表
b = [4,5,6]
zipped = zip(a,b)
print(zipped)
#<zip object at 0x00000200CFC1F400> #返回的是一个对象

a , b = zip(*zipped) # *zipped 可理解为解压，返回二维矩阵式
print(a , b)
#(1, 2, 3) (4, 5, 6)


#reduce() 函数会对参数序列中元素进行累积。
from functools import reduce

def add(x, y) :            # 两数相加
    return x + y
sum1 = reduce(add, [1,2,3,4,5])   # 计算列表和：1+2+3+4+5
sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5])  # 使用 lambda 匿名函数
print(sum1)
print(sum2)
  
```

- 描述Quick Sort 如何用Python实现

```Python
def partition(arr, low: int, high: int):
    pivot, j = arr[low], low  # 获取底部元素与 对应的初始下标

    for i in range(low + 1, high + 1):  # 从第2个元素开始，到最后一个元素
        if arr[i] <= pivot:  # 如果这个元素，小于第1个元素
            j += 1  # 初始下标+1
            arr[j], arr[i] = arr[i], arr[j]  # 把这个小元素和标的元素换位置
    arr[low], arr[j] = arr[j], arr[low]  # arr[low]是等于自己的，现在把他挪到中间位置
    return j  # 返回这个中间位置


def quick_sort_between(arr, low: int, high: int):
    if high-low <= 1:  # 递归结束条件
        return

    m = partition(arr, low, high)
    quick_sort_between(arr, low, m - 1) # 二分后自我调用，直到递归结束条件触发
    quick_sort_between(arr, m + 1, high)


def quick_sort(arr):
    """
    快速排序(in-place)
    :param arr: 待排序的List
    :return: 快速排序是就地排序(in-place)
    """
    quick_sort_between(arr, 0, len(arr)-1)  # arr[0] - arr[len(arr)-1]

# 测试数据
if __name__ == '__main__':
    arr = [17, 56, 71, 38, 61, 62, 48, 28, 57, 42, 10, 21, 12, 90]  # 长度为10
    quick_sort(arr)
    print("快速排序结果：", arr)
```

- 将字典数组按字典的某个key排序？

方法1：

```language
sorted(d.cop(),key = lambda i:i[k])
```

方法2：

```language
heappush(h,(i[k],i)) for i in d
```

- 迭代器和生成器有什么区别？

在 Python 中，使用了 yield 的函数被称为生成器（generator）。跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。

调用一个生成器函数，返回的是一个迭代器对象：迭代是Python最强大的功能之一，是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。迭代器有两个基本的方法：iter() 和 next()

- Python中生成器和协程有什么区别？
  生成器函数与协程（注：函数）非常相似，它们 yield 多次，它们具有多个入口点，并且它们的执行可以被挂起。唯一的区别是生成器函数不能控制在它在 yield 后交给哪里继续执行，控制权总是转移到生成器的调用者
- 在Python创建协程时，task 和 future有什么区别？

task是future的子类，所以task继承了future的属性和方法。几乎没有不同。

- yiled from 是用来做什么的?

```Python
使一个生成器可以委派子生成器，建立双向通道
def g1(x):
   yield range(x, 0, -1)
   yield range(x)
print(list(g1(5)))
#[range(5, 0, -1), range(0, 5)]

def g2(x):
   yield from range(x, 0, -1)
   yield from range(x)
print(list(g2(5)))
#[5, 4, 3, 2, 1, 0, 1, 2, 3, 4]
```

- __new__和 __init__的区别？

执行顺序的不同：只有在__new__返回一个cls的实例时后面的__init__才能被调用

功能上的不同：当创建一个新实例时调用__new__,初始化一个实例时用__init__

返回值的不同：__new__方法会返回一个创建的实例,而__init__什么都不返回

- 使用import 语句导入包时，查找顺序时怎么样的？

通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：

> 前目录，即当前执行的程序文件所在目录下查找；
> 到 PYTHONPATH（环境变量）下的每个目录中查找；
> 到 Python 默认的安装目录下查找。

以上所有涉及到的目录，都保存在标准模块 sys 的 sys.path 变量中，通过此变量我们可以看到指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 sys.path 显示的目录中，那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。

解决“Python找不到指定模块”的方法有 3 种，分别是：

> 向 sys.path 中临时添加模块文件存储位置的完整路径；
> 将模块放在 sys.path 变量中已包含的模块加载路径中；
> 设置 path 系统环境变量。

- Python的垃圾回收机制？

```Python
# 生以下四种情况的时候，该对象的引用计数器+1
a= 999 # 对象被创建  
b=a   # 对象被引用 
def func(a):
    return
func(a)   # 对象被作为参数,传到函数中
List=[a,"a","b",2]   # 对象作为一个元素，存储在容器中   

#发生以下四种情况时，该对象的引用计数器**-1**

#该对象的别名被显式销毁时    
del a
#该对象的引别名被赋予新的对象，   
a = 999
#个对象离开它的作用域，例如 func函数执行完毕时，函数里面的局部变量的引用计数器就会减一（但是全局变量不会）
#该元素从容器中删除时，或者容器被销毁时。
b = a  # 当前计数器为2
del b # 删除变量b：b对应的对象的引用计数器-1   （此时计数器为1）
del a # 删除变量a：a对应的对象的引用计数器-1    (此时引用计数器为0)

# 当引用计数器为0 时，意味着没有人再使用这个对象，这个对象就变成垃圾，垃圾回收。
# 回收：1.对象从refchain的链表移除。
#.将对象进行销毁，内存归还给操作系统，可用内存就增加。
```

### 举例说明什么是修饰器

故事的开始是这样的，你写好了2个函数：

```language
def test1(): 
  print('test1 ..')

def test2():
  print('test2 ..')

test1()
test2()
```

当你准备把它放到服务器上，这个时候领导提醒你要输出日志，不然查错跑断腿。
输出要求是：在每次函数调用的前后加上时间。
于是你写成了下面这个样子

```language
import time
def test1(): 
    print('测试开始：现在时间是',time.time())
    print('test1 ..')
    print('测试结束：现在时间是',time.time())

def test2():
    print('测试开始：现在时间是',time.time())
    print('test2 ..')
    print('测试结束：现在时间是',time.time())

test1()
test2()
```

领导说，他有3个问题：

- 首先代码1和代码2是一样的，也就是说把同样的代码写了2遍，这一点也不程序员！
- 而且，你修改了你的核心代码，使得它变得很长。后面要再删也很麻烦，万一手抖删错了就完了。
- 最后，在大项目合作中，可能test代码是A同事写的，输出日志代码是B同事写的，代码保密，每个程序员只能拿到部分片段，所以你根本不知道对方的代码，要提供一个通用的打印日志的方式。

思考下，可以怎么修改能既不修改源代码，又对代码结构影响最小呢？

我说，这样子，那我可以写成这样？

```language
import time

def a_decorator(func):
    print('测试开始：现在时间是',time.time())
    func()
    print('测试结束：现在时间是',time.time())

def test1(): 
    print('test1 ..')
  
def test2():
    print('test2 ..')

a_decorator(test1)
a_decorator(test2)
```

领导说：有进步，但是原本调用test1()的语法被你改成了a_decorator(test1)，这要是再多几个功能不得把我绕晕了啊。

看来函数嵌套掌握的不熟啊，给你点提示，我带你透过现象看本质

- 变量的本质：就是变量指向的内存地址
- 函数名的本质：就是函数的内存地址
- 变量可以作为函数的参数，因此函数名可以用做函数的参数
- 变量可以作为函数的返回值，同理，函数名也可以作为函数的返回值

我说，那就写成这样？

```language
import time

def a_decorator(func):
    def wrap_the_func():
        print('测试开始：现在时间是',time.time())
        func()
        print('测试结束：现在时间是',time.time())
    return wrap_the_func

def test1(): 
    print('test1 ..')
  
def test2():
    print('test2 ..')

test1 = a_decorator(test1) #这里a_decorator(test1) 代指wrap_the_func()，把这个wrap_the_func()函数的地址赋值给test1，由于代码从上而下执行，从而替换掉原本test1的指向。
test2 = a_decorator(test2)

test1()
test1()
```

领导说：这倒数3、4行看着很碍眼，且会占据命名空间，你不会修饰符吗？我教你啊。

- 我们先定义一个函数（名字随便起，这里只是用a_decorator做示例）
- 然后简单的设置下这个函数运行逻辑，
- 最后在原有的函数的头上加@函数名就行啦

直接使用@函数修饰符是很方便的，你也看出来所谓【@函数修饰符】其实就是【函数】嵌入。

这里我再假设你的函数是带参数的。我也用修饰符写一下吧。好好看，好好学。

核心代码（下方的test函数）无需知道我（下方的log函数）是怎么写的，我也无需知道核心代码是怎么写的，我们就能快速完成协作。

```language
import time

#args 是 arguments 的缩写，表示位置参数；
#kwargs 是 keyword arguments 的缩写，表示关键字参数。
#这其实就是 Python 中可变参数的两种形式，
#并且 *args 必须放在 **kwargs 的前面，因为位置参数在关键字参数的前面。

def log(func):
  def wrapper(*args,**kwargs):
    print('测试开始：现在时间是',time.time())
    ret = func(*args,**kwargs)
    print('测试结束：现在时间是',time.time())
    return ret
  return wrapper

@log
def test1(s): 
  print('test1 ..', s)
  return s
@log
def test2(s1, s2):
  print('test2 ..', s1, s2)
  return s1 + s2

test1(1)
test2(1,2)
```

于是你回想起之前Python也提供了一些自带函数，例如：print()、input()

那会不会也有一些自带的【@函数修饰符】呢？还真有，常见的包括：@property、@classmethod、@staticmethod还有typing里面各种用于测试的函数。

不过这些结构相对复杂，当你理解普通的@修饰符之后，这些自带的你只需要记得用法即可，原理都是一样的。

### 闭包

#### 闭包作用

闭包可以用在许多地方。它的最大用处有两个：

1.可以读取函数内部的变量
2.让这些变量的值始终保存在内存中
3.单向访问，函数内可以访问，但是全局不能访问

#### 闭包原理（命名空间与作用域）

##### 命名空间

- 全局命名空间：创建的存储“变量名与值的关系”的空间叫做全局命名空间
- 局部命名空间：在函数的运行中开辟的临时的空间叫做局部命名空间
- 内置命名空间：内置命名空间中存放了python解释器为我们提供的名字：input,print,str,list,tuple...它们都是我们熟悉的，拿过来就可以用的方法。

三种命名空间之间的加载顺序和取值顺序：

- 加载顺序：内置（程序运行前加载）-->全局（从上到下顺序加载进来的）-->局部（调用的时候加载）--->内置
- 取值：在局部调用：局部命名空间--->全局命名空间--->内置命名空间
- 在全局范围找：全局----内置----局部
  使用：
  全局不能使用局部的，局部的可以使用全局的

##### 作用域

作用域：就是作用范围，为了函数内的变量不会影响到全局。作用域分为两种：

- 全局作用域：全局命名空间与内置命名空间的名字都属于全局范围在整个文件的任意位置都能被引用，全局有效
- 局部作用域：局部命名空间，只能在局部范围内生效
  站在全局看：使用名字的时候：如果全局有，用全局的。如果全局没有，用内置的。
- globals方法：查看全局作用域的名字【print(globals())】
- locals方法：查看局部作用域的名字【print(locals())】
  `<br>`下面看2个示例

##### 闭包失败示例

```language
name = 1 #变量在函数外部,inner可以访问，但是全局也能访问。直接闭包失败
def func():
    def inner():
        print(name)
        print(inner.__closure__)
        return name
    return inner

p = func()
print(p())#输出的__closure__为None ：不是闭包函数
print(name)
```

##### 闭包成功示例

```language
def func():
    name = 1 #变量在函数内部,inner可以访问,但是全局不能访问。闭包成功！此时加上nonlocal
    def inner():
        nonlocal name
        # nonlocal非局部声明变量 是python3.2的语法,简单说就是让内部函数中的变量在上一层函数中生效
        # 非局部声明变量指代的已有标识符是最近外面函数的已声明变量，但是不包括全局变量。这个是很重要的，因为绑定的默认行为是首先搜索本地命名空间。nonlocal声明的变量只对局部起作用，离开封装函数，那么该变量就无效。
        name += 1
        print(inner.__closure__)
        return name
    return inner

p = func()
print(p())
print(p())
print(p())

print(name)
```

### 单例模式

单例模式就是确保一个类只有一个实例.当你希望整个系统中,某个类只有一个实例时,单例模式就派上了用场.

比如,某个服务器的配置信息存在在一个文件中,客户端通过AppConfig类来读取配置文件的信息.如果程序的运行的过程中,很多地方都会用到配置文件信息,则就需要创建很多的AppConfig实例,这样就导致内存中有很多AppConfig对象的实例,造成资源的浪费.其实这个时候AppConfig我们希望它只有一份,就可以使用单例模式.

#### 使用闭包函数实现单例模式

```language
def single(cls, *args, **kwargs):
    instance = {}

    def get_instance():
        if cls not in instance:
            instance[cls] = cls(*args, **kwargs)
        return instance[cls]
    return get_instance


@single
class Apple:
    pass

# 测试新建2个不同实例，id是否一致
a = Apple()
print(id(a)) 
b = Apple()
print(id(b))
```

#### 也可以直接使用__new__方法实现的单例模式

```language
class Single:
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            cls._instance = super(Single, cls).__new__(cls)
        return cls._instance


s1 = Single()
s2 = Single()
print(id(s1))
print(id(s2))
```

## Python调用C

Python的底层是C写的（实际上大部分高级编程语言都是C写的）因此互相调用的逻辑主要是：数据类型转换、编译库的链接、接收返回值。

这个过程涉及到反复的调试，所以先从调试开始讲。

### Visual Studio Code 和 Visual Studio的调试

#### Visual Studio Code

先看我们熟悉的Visual Studio Code ，以下简称VScode

点击“行号”前的位置，就可以给代码行打上红色的“断点”。

```Python
def mynameis(x):
    print('my name is ',end='')
    print(x,end='')# 断点
    print("!")


print(1)# 断点
mynameis('a')
print(2)# 断点
mynameis('b')
print(3)
```

接着点击刚刚的调试按钮，点击运行和调试，接着根据你的文件类型选择，譬如py文件就选择Python File. 然后可以看到代码上方有6个按钮。他们分别是：

> 1、continue（继续）
> 执行到下一断点，如果函数内容的子函数也有断点，会跳到子函数的断点处

> 2、step over（单步跳过）
> 一行一行的往下走，把没有断点的子函数当作一步，如果子函数内有断点，会跳到子函数的断点处，从断点处开始一行一行执行

> 3、step into（单步调试/单步执行）
> 一行一行往下走，如果这一行上有子函数，且无论子函数内有无断点，都会跳到子函数的第一行，从第一行开始，一行一行执行

> 4、step out（单步跳出）
> 执行到下一断点，如果遇到子函数，且子函数内没有断点，直接跳出子函数。如果子函数内有断点，会在执行完断点后再跳出子函数

> 5、Restart（重启）
> 从头开始，重新运行调试代码

> 6、stop（停止）
> 停止运行调试代码

接着打上断点，感受一下这几个按钮的功能吧。

#### Visual Studio

都是微软开发的软件，大同小异。

```C
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <windows.h>
using namespace std;

#include "test.h"


//定义一个全局结构体,作用域到文件末尾
struct Person {
    int age;
    char* name;
};

void test20() {
    //使用全局的结构体定义结构体变量p
    char x[] = "我是谁";
    struct Person p = { 10 ,x };

    printf("%d,%s\n", p.age, p.name);
}

int main(int argc, const char* argv[])
{
    //定义局部结构体名为Person,会屏蔽全局结构体
    //局部结构体作用域,从定义开始到“}”块结束
    struct Person {
        int age;
    };
    // 使用局部结构体类型
    struct Person pp;
    pp.age = 50;
    //pp.name = "zbz"; 会报错，没有name

    test20(); // 10 , 我是谁

    int a = 1;
    return 0;
}
```

我们先在红色区域（数字1）打上断点

再在绿色区域（数字2）点击调试

最后蓝色区域找到这个6个按钮

前面2个分别是stop（停止）和Restart（重启）

后面的1、2、3、4则依次对应着：continue（继续）、step over（单步跳过）、step into（单步调试/单步执行）和step out（单步跳出）

### 代码的互相调用

#### 在Python中调用C（原生的Python.h）

python+c/c++混合编程如：

> 原生的Python.h

> cython

> pybind11：pytorch也采用该方法

> ctypes、cffi、SWIG、Boost.Pytho 等

但不论是哪个方法，大致的流程都是：转换数据类型->编译代码->生成编译后的文件（.pyd .pyc .pyo .so .dll 等）

```language
冷知识：

python的import不止能导入.py后缀结尾的文件

pyc是由py文件经过编译后生成的二进制文件，py文件变成pyc文件后，加载的速度有所提高，并且可以实现源码隐藏。

pyo是优化编译后的程序，也可以提高加载速度，针对嵌入式系统，把需要的模块编译成pyo文件可以减少容量。

.so和.dll分别是Linux和window的动态库
```

#### 环境设置

- 首先我们找到python的安装路径，通过文件搜索找到Python.h的文件夹路径
- 【设我的Python路径为C:\Python】
- 那么Python.h的文件位置就是：C:\Python\include 简称H路径
- python310_d.lib的位置就是：C:\Python\libs 简称L路径
- 接着右击【项目】，点击属性

- 最后在上方选择所有配置、所有平台。点击VC++目录，选择包含目录最右边的下拉三角，输入刚刚复制的**H路径**即可

- 接着再来载入python310_d.lib库，打开L路径查看里面有无python310_d.lib这个文件，【注意，310是python版本号，不同版本对应不同文件名】如果没有，则复制python310.lib，然后重命名。
- 还是打开刚刚的属性，依次设置。
- 库目录填【文件夹路径】

- 附加依赖项填【文件路径】

#### 代码编写

- 新建一个文件名，根据官方文档的说法，以C语言为例，如果一个模块叫 spam，则对应实现它的文件名叫 spammodule.c；如果这个模块名字非常长，比如 spammify，则这个模块的文件可以直接叫 spammify.c

这里我调整了一下官方文档给的示例，添加了一些注释。让新手更易读。

```C
#define PY_SSIZE_T_CLEAN
#include <Python.h>

static PyObject* spam_system(PyObject* self, PyObject* args)
{
    /*
     self 参数指向模块对象；对于方法则指向对象实例。

     args 参数是指向一个 Python 的 tuple 对象的指针，其中包含参数。
     每个 tuple 项对应一个调用参数。 这些参数也全都是 Python 对象
     要在我们的 C 函数中使用它们就需要先  将其转换为 C 值。
    */

    const char* command;
    int sts;
    //PyArg_ParseTuple() 会检查参数类型并将其转换为 C 值。 
    //它使用模板字符串确定需要的参数类型以及存储被转换的值的 C 变量类型。
    //在所有参数都有正确类型且组成部分按顺序放在传递进来的地址里时，返回真(非零)。
    //其在传入无效参数时返回假(零)。在后续例子里，还会抛出特定异常，使得调用的函数可以理解返回 NULL(也就是例子里所见)。
    // "s" 是一个参数，将 Unicode 对象转换为指向字符串的 C 指针。具体可以参考 https://docs.python.org/3/c-api/arg.html
    if (PyArg_ParseTuple(args, "s", &command)) {

        // system 是C的库函数，从属于stdlib标准库,【片面】的说：
        // 返回值是0表示成功 
        // 返回值是其他表示执行失败
        // 至于为什么是片面的，原因会在下个阶段解释。
        sts = system(command);

        //PyLong_FromLong返回一个表示 Python 整数对象的 PyObject 子类型。
        return PyLong_FromLong(sts);
    }
    else {
        return NULL;
    }
}

// 构造方法
static PyMethodDef SpamMethods[] = {
    {"system",  spam_system, METH_VARARGS,
     "Execute a shell command."},
    {NULL, NULL, 0, NULL}        /* Sentinel */
};

// 调用构造方法
static struct PyModuleDef spammodule = {
    PyModuleDef_HEAD_INIT,
    "spam",   /* name of module */
    NULL, /* module documentation, may be NULL */
    -1,       /* size of per-interpreter state of the module,
                 or -1 if the module keeps state in global variables. */
    SpamMethods
};
// 初始化
PyMODINIT_FUNC
PyInit_spam(void)
{
    return PyModule_Create(&spammodule);
}

int
main(int argc, char* argv[])
{
    wchar_t* program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }
    /* Add a built-in module, before Py_Initialize */
    if (PyImport_AppendInittab("spam", PyInit_spam) == -1) {
        fprintf(stderr, "Error: could not extend in-built modules table\n");
        exit(1);
    }
    /* Pass argv[0] to the Python interpreter */
    Py_SetProgramName(program);
    /* Initialize the Python interpreter.  Required.
       If this step fails, it will be a fatal error. */
    Py_Initialize();
    /* Optionally import the module; alternatively,
       import can be deferred until the embedded script
       imports it. */
    PyObject* pmodule = PyImport_ImportModule("spam");
    if (!pmodule) {
        PyErr_Print();
        fprintf(stderr, "Error: could not import module 'spam'\n");
    }

    PyMem_RawFree(program);
    return 0;
}

```

#### 打包分发

这里Python 3.12 以前的老项目可以使用distutils模块，更推荐使用setuptools模块，setuptools最常用的功能有：

- 依赖包安装与版本管理
- python库的打包分发
- c/c++ 拓展
- python环境限制与生成脚本

整个打包过程最重要的就是**setup.py**，它指定了重要的配置信息。setup.py的内容如下(示例)：

```python
from setuptools import setup,Extension

setup(
    ext_modules=[
    Extension(
    name = 'spam', # 包名称
    sources=['spammodule.cpp'],
    )]
)
```

通过setup函数的这些参数packages、include_package_data（其实就是MANIFEST.in文件）、exclude_package_data、package_data、data_files来指定需要打包的文件。

包含的文件如下：

- py_modules 和 packages 参数中所有 Python 源文件
- ext_modules or libraries 参数中提到的所有 C 源文件
- scripts 参数指定的脚本
- package_data 和 data_files 参数指定的所有文件
- setup.cfg 和 setup.py
- 类似于readme的文件（如README、README.txt、 README.rst、README.md）
- MANIFEST.in 中指定的所有文件（当运行python setup.py sdist时，会查阅MANIFEST.in文件，并且将里面约定的文件打包到最后的包里。什么要，什么不要）

打包命令说明：

1. 源码包source dist（简称sdist）：就是我们熟悉的 .zip 、.tar.gz 等后缀文件。就是一个压缩包，里面包含了所需要的的所有源码文件以及一些静态文件（txt文本、css、图片等）。

```python
python setup.py sdist --formats=gztar
```

2. 二进制包binary dist（简称bdist）：格式是wheel（.whl后缀），它的前身是egg。wheel本质也还是一个压缩包，可以像像zip一样解压缩。与源码包相比，二进制包的特点是不用再编译，也就是安装更快！在使用wheel之前，需要先安装wheel模块

```python
# 先安装wheel模块
pip install wheel

python setup.py bdist --formats=rpm
# 等价于
python setup.py build_rpm
```

3. 开发方式安装包，该命名不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。

```python
pip install -e .
等价于
python setup.py develop
```

4. 构建扩展，如用 C/C++, Cython 等编写的扩展，在调试时通常加 --inplace 参数，表示原地编译，即生成的扩展与源文件在同样的位置。

```python
python setup.py build_ext --inplace
```

5. 构建一个 wheel 分发包，egg 包是过时的，whl 包是新的标准

```python
python setup.py bdist_wheel
```

6. 构建一个 egg 分发包，经常用来替代基于 bdist 生成的模式

```python
python setup.py bdist_egg
```

7. 安装到库

```python
python setup.py install
#等价于
python setup.py build
python setup.py install

#python setup.py install包括两步：python setup.py build python setup.py install。
#这两步可分开执行， 也可只执行python setup.py install, 因为python setup.py install总是会先build后install.


#根据生成的文件等价于
pip install  xxx.zip
# 或
pip install xxx.whl
# 或.... xxx.egg
```

## 计算机基础

### Process

进程是系统独立安排和分配系统资源（CPU、内存）的基本单位。

进程之间是相互独立的，Python中的进程通信一般由进程对Queue完成。

进程绕过了全局解释器锁。因此，多进程模块允许程序员充分利用特定机器上的多个处理器。它在Unix和Windows上都能运行。

进程的数量等于CPU核心的数量，这是最有效的。如果核数太多，就不能充分利用核数。如果太少，会造成进程切换，增加程序的运行时间。

[multiprocessing](https://docs.python.org/zh-cn/3.10/library/multiprocessing.html?highlight=multiprocessing#module-multiprocessing):Multiprocessing Module Code Documentation

```Python
from multiprocessing import Pool

def f(vaule):
    x = vaule[0]
    y = vaule[1]
    return x*y

if __name__ == '__main__':
    p = Pool(16) # new 16 process pools ， because i have 16 cpu
    print(p.map(f, [(1,1), (2,2), (3,3)])) # take in data
    p.close() # close pool
  
## [1, 4, 9]
```

### Thread

线程是系统调度资源的最小单位（CPU通过计时器来切换线程）

在Python中，同个时间只有一个线程在运行

当然，如果你运行大量的I/O任务，多进程依然是最好的选择

线程数等于 CPU 内核数的两倍是最高效的。

GIL 是一个防止多个线程同时执行 Python 字节码的互斥锁。之所以需要这种锁，主要是因为 CPython 的内存管理不是线程安全的

在这种环境下，GIL 限制解释器本身只能有一个线程运行，而且任何 Python 解释器级别的操作都是序列化的，因此任何时候都只能有一条语句抛出异常。与异常相关的共享变量也因此受到保护。

线程间通信的目的主要是为了线程同步，因此线程没有像进程通信那样用于数据交换的通信机制。

[threading](https://docs.python.org/zh-cn/3.10/library/threading.html?highlight=threading#module-threading):Threading Multiprocessing Module Code Documentation

```Python
import time
import threading


def test_thread(para='hi', sleep=3):
    time.sleep(sleep)
    print(para)


def main():
    # create thread
    thread_hi = threading.Thread(target=test_thread)
    thread_hello = threading.Thread(target=test_thread, args=('hello', 1))
    # run thread
    thread_hi.start()
    thread_hello.start()
    print('Main thread has ended!')


if __name__ == '__main__':
    main()
```

### Coroutines

协程是编写并发代码的库，是构建 IO 密集型和高级结构化网络代码的最佳选择。

例程的运行方式是通过代码主动切换状态并等待处理，因此效率更高，语法也更详细。循环对象需要处于活动状态：创建、设置、提交、等待运行和停止。

例行程序的最佳数量取决于内存使用情况。

[asyncio](https://docs.python.org/zh-cn/3.10/library/asyncio.html?highlight=asyncio#module-asyncio):asyncio Multiprocessing Module Code Documentation

```Python
import asyncio 

class TestA: 
    def __init__(self,loop) -> None:
        self.loop = loop
        asyncio.set_event_loop(loop=self.loop) # step 3.1

    async def run_page(self,tid): # step 7 
        print(tid)
        return tid

    async def close(self,):
        for i in asyncio.all_tasks(): # step 9.1
            i.cancel()
        self.loop.stop() # step  9.2


def test():
    get_async_loop = asyncio.new_event_loop() # step 1
    asyncio.set_event_loop(get_async_loop) # step 2

    async def spider(task_obj):
        async_task =  [asyncio.ensure_future(task_obj.run_page(1)),
                    asyncio.ensure_future(task_obj.run_page(2)),] # step  6
        await asyncio.wait(async_task) # step  8

        await task_obj.close() # step 9
  
    task_obj = TestA(get_async_loop) #step 3
    asyncio.run_coroutine_threadsafe(spider(task_obj), loop=get_async_loop) #step  4
    get_async_loop.run_forever() # step 5

test()
```

## 笔试-后缀表达式

### 描述

后缀表达式，又称逆波兰式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。

例如：后缀表达式为“2 3 + 4 × 5 -”计算过程如下：
（1）从左至右扫描，将 2 和 3 压入堆栈；
（2）遇到 + 运算符，因此弹出 3 和 2（ 3 为栈顶元素，2 为次顶元素，注意与前缀表达式做比较），计算出 3+2 的值，得 5，再将 5 入栈；
（3）将 4 入栈；
（4）接下来是 × 运算符，因此弹出 4 和 5，计算出 4 × 5 = 20，将 20 入栈；
（5）将 5 入栈；
（6）最后是-运算符，计算出 20-5 的值，即 15，由此得出最终结果。

示例

listx = [15, 7, 1, 1, "+", "-", "/", 3, "*", 2, 1, 1, "+", "+", "-"]

### 题解

```python

# 方法1-python人思维
while len(listx) > 1:
    print(listx)
    for i in range(len(listx)):
        if str(listx[i]) in '+-*/':
            if listx[i] == '+':
                new = listx[i-2] + listx[i-1]
            if listx[i] == '-':
                new = listx[i-2] - listx[i-1]
            if listx[i] == '*':
                new = listx[i-2] * listx[i-1]
            if listx[i] == '/':
                new = listx[i-2] / listx[i-1]
            del listx[i]
            del listx[i-1]
            listx[i-2] = new
            break
print(listx)

# 方法2-利用pop 和 append 仿c语言栈操作
listy = []
for i in listx:
    if str(i) not in "+-*/":
        listy.append(i)  # 入栈
    else:
        if i == "+":
            new = listy.pop() + listy.pop()  # 出栈
        if i == "-":
            new = listy.pop() - listy.pop()
        if i == "*":
            new = listy.pop() * listy.pop()
        if i == "/":
            new = listy.pop() / listy.pop()
        listy.append(new)
print(listy)
```

## 笔试-求解密码

### 描述

Python中的string模块包含了许多字符，请根据以下提示设计一个函数：

参数1：不同的密码组合类型
参数2：密码长度

输出：所以可能的组合数量

示例：当仅用**小写字母**和**数字**来组成1位密码时，共有36种可能（26+10）

string.ascii_letters 所有字母
string.ascii_uppercase  大写字母
string.ascii_lowercase  小写字母
string.digits   数字
string.punctuation  标点符号
string.printable    可打印字符
string.whitespace   空白字符

### 题解

```python
import string
# 方法1 正常Python人思维
def generate_pwd_list(dic, max_len):
    """
    description:生成指定长度的密码序列
    param {*} dic   字典
    param {*} pwd_len   最大密码长度
    return {*}
    """
    k = itertools.product(dic, repeat=max_len)  # 迭代器
    allkey = ("".join(i) for i in k)
    if max_len == 1:
        return list(allkey)
    return generate_pwd_list(dic, max_len - 1) + list(allkey)


keys = generate_pwd_list(string.ascii_lowercase + string.digits, 1)
print(len(keys))


# 方法2 递归
def combi(seq):
    if not seq:
        yield []
    else:
        for element in seq[0]:
            for rest in combi(seq[1:]):
                yield [element] + rest


def sets(dic, pwd_len):
    n = []
    for i in range(pwd_len):
        n.append(dic)
    return list(combi(n))


print(len(sets(string.ascii_lowercase + string.digits, 2)))



# 方法3 迭代器


res = []


def func(arr, index, temp):
    if len(temp) == len(arr):
        res.append(temp[:])
    else:
        for i in range(len(arr[index])):
            temp.append(arr[index][i])
            func(arr, index + 1, temp)
            temp.pop()


def sets(dic, pwd_len):
    n = []
    for i in range(pwd_len):
        n.append(dic)
    func(
        n,
        0,
        [],
    )


sets(string.ascii_lowercase + string.digits, 2)
print(len(res))


```

```
