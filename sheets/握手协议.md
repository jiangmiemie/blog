---
tags: [web]
---
## Web Security Knowledge

### SSL/TLS

SSL/TLS是一种密码通信框架，是世界上使用最广泛的密码通信方式。 SSL/TLS是对称密码、消息认证码、公钥密码、数字签名、伪随机数发生器等技术的结合，堪称密码学的杰作。

SSL/TLS 是一个安全的通信框架，可以承载 HTTP 协议或 SMTP/POP3 协议等。

SSL（Secure Socket Layer）是 Netscape 于 1994 年设计并于 1995 年发布的 3.0 版协议。

TLS（Transport Layer Security）是IETF基于SSL 3.0设计的协议，实际上相当于SSL的后续版本。

TLS主要分为两层，最底层是TLS记录协议，主要负责使用对称密码对消息进行加密。

上层是TLS握手协议，主要分为4个部分：握手协议、密码规范变更协议和应用数据协议。

- 握手协议负责就客户端和服务器之间的密码算法和共享密钥达成一致，包括证书认证，是四个协议中最复杂的。
- 密码规范更改协议负责向通信方发送密码更改信号
- 警告协议负责在发生错误时将错误信息传达给对方
- 应用数据协议负责将TLS携带的应用数据传送给通信方。

## Interview frequently asked

### TCP connection and closing process

#### Three waves and the reason

在TCP/IP协议中，TCP协议提供可靠的连接服务，使用三次握手建立连接

##### First handshake

(a) 建立连接时，客户端向服务器发送一个syn包（syn=j），并进入SYN_SEND状态，等待服务器确认；

SYN：同步序列号（Synchronize Sequence Numbers）。 它是TCP/IP建立连接时使用的握手信号。 当客户端和服务器之间建立正常的TCP网络连接时，客户端首先发送一个SYN报文，服务器响应一个SYN+ACK表示已经收到消息，最后客户端响应一个ACK报文。

这样就可以在客户端和服务器之间建立可靠的TCP连接，并在客户端和服务器之间传递数据。

##### Second handshake

服务器收到一个 SYN 包，必须确认客户端的 SYN（ack=j+1），同时自己发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；

ACK（Acknowledge character）是确认字符，是数据通信中接收站向发送站发送的传输类控制字符。 表示发送的数据已经正确接收。

在TCP/IP协议中，如果接收方成功接收到数据，它会回复一个ACK数据。 通常ACK信号有自己固定的格式、长度和大小，由接收方回复给发送方。

##### Third handshake

客户端收到服务器发来的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送后，客户端和服务器进入ESTABLISHED状态，完成三次握手。

第三次握手是为了防止失败的连接请求报文段突然又传给服务器，从而产生错误。

例如，如果请求是在这样一种情况下发起的：客户端发送的第一个连接请求在网络节点中由于某种原因延迟，直到某个时间点释放连接才到达服务器，这 是一条久违的消息，但是服务器仍然认为这是客户端连接请求的第一次握手，所以服务器以第二次握手响应客户端。

如果只有两次握手，那么至此，连接已经建立，但是此时客户端还没有任何数据可以发送，服务器还在傻傻的等待好消息，造成了资源的极大浪费。 所以需要第三次握手，只有客户端再次响应才能避免这种情况。

#### Four handshakes and the reason

##### First wave

Client发送一个FIN，用于关闭Client到Server的数据传输，Client进入FIN_WAIT_1状态。

##### Second wave

Server收到一个FIN，发送ACK给Client，确认收到的序号+1（同SYN，一个FIN占用一个序号），Server进入CLOSE_WAIT状态

##### Third wave

Server发送一个FIN，用于关闭Server到Client的数据传输，Server进入LAST_ACK状态

##### The fourth wave

Client收到FIN，Client进入TIME_WAIT状态，然后向Server发送ACK，收到确认号+1，Server进入CLOSED状态，完成四次挥手。

所谓四次挥手就是终止TCP连接，也就是断开一个TCP连接，客户端和服务端一共需要交互四次。 该过程由执行 CLOSED 的客户端或服务器触发。

由于 TCP 连接是全双工的，每个方向都必须单独关闭。 原理是当一方发送完数据后，发送一个FIN终止该方向的连接。 首先执行关机的一方将执行主动关机，而另一方将执行被动关机。

在四波时，发起关闭的一方将进入 TIME_WAIT 状态，并且该状态将保持两倍最大段生命周期 (2MSL)。

为什么我们不直接关闭，进入等待状态呢？

1、保证client发送的ACK报文段能够到达server，从而保证tcp连接能够可靠的关闭。

这个很好理解，如果client关闭后立即发起ACK，那么如果ACK丢了，server会一直处于等待关闭确认的状态，然后超时后发送关闭请求，client 此时已经关闭，则服务器无法正常关闭。

2.保证本次连接的数据段消失，防止无效数据段。

client发送ACK后，等待2MSL，使本次连接产生的数据段从网络中消失，从而保证关闭连接后不会再有数据段还徘徊在网络中骚扰server；

还有一点，如果客户端重新发送请求，如果之前连接的一些数据还在网络中徘徊，这些延迟的数据只有在新连接建立后才能到达Server，而由于新连接的端口号和 old connection是一样的，由于TCP协议是根据socket pair来判断不同的连接，所以TCP协议认为延迟的数据是属于新连接的，与真正的新连接的数据包相混淆。

为什么是2MSL？

我们知道服务器收到一个ACK并关闭连接。 但是client没有办法知道ACK有没有到达server，所以就开始等待了？ 等什么？ 如果ACK没有到达服务器，服务器会超时重传超时重传FIN报文，那么如果客户端等待足够长的时间收到FIN报文，就说明ACK没有到达服务器，所以发送ACK 直到没有足够的时间收到FIN，说明ACK已经成功到达。 这个等待时间至少为：服务器的超时时间+FIN发送时间，为了保证可靠性，使用了比较保守的等待时间2MSL。

MSL，Maximum Segment Life，是TCP Segment生存时间的TCP限制。

客户端发送ACK，等待ACK到达超时时间MSL的对方，等待FIN超时重传，也是MSL，所以如果在2MSL时间内没有收到FIN，说明对方安全 收到 FIN
